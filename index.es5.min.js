class EventEmitter{constructor(){this.listeners={}}addEventListener(t,i){t in this.listeners||(this.listeners[t]=[]),this.listeners[t].push(i)}removeEventListener(t,i){const n=this.listeners[t]||[],s=n.indexOf(i);-1!==s&&n.splice(s,1)}emit(t,i){(this.listeners[t]||[]).forEach(t=>{t.call(this,i)})}}class Dispatcher extends EventEmitter{constructor(){super(),this.token=`dispatch${Math.random()}`,this.lock=!1,this.dispatch=this.dispatch.bind(this)}dispatch(t){if(this.lock)throw new Error("can`t dispatch in the middle of a dispatch");this.emit(this.token,t)}}const CHANGE="CHANGE";class Store extends EventEmitter{constructor(t,i){super(),this.opts=i||{},this.dispatcher=t,["__dispatch","__emitChange","getDispatcher"].forEach(t=>{this[t]=this[t].bind(this)}),t.addEventListener(t.token,i=>{t.lock=!0;this.__dispatch(i);t.lock=!1})}getDispatcher(){return this.dispatcher}addListener(t){return this.addEventListener(CHANGE,t),{remove:()=>this.removeEventListener(CHANGE,t)}}__emitChange(){this.emit(CHANGE)}__dispatch(t){throw new Error("needs implementation")}}class Actions{constructor(t,i){this.opts=i||{};const n=this.opts.name||this.constructor.name,s=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(this));this.actionTypes={},this.dispatch=t,Object.keys(s).filter(t=>s[t].value&&"constructor"!==t).forEach(t=>this.actionTypes[t]=`${n}_${t}`)}}export{Dispatcher,Store,Actions,EventEmitter};